// Copyright 2020 Frederik Zipp. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Calculates the points of a Catmull-Rom spline chain along a given series
// of control points, writes the result to the standard output, and optionally
// generates a plot image of the curve.
//
// Usage:
//
//	spline [-pps n] [-alpha a] [-plot png_image_file] [control_points_file]
//
// Flags:
//
//	-pps    Points per segment between two control points.
//	        (optional, default: 10)
//	-alpha  Alpha value (optional, default: 0.5). The alpha value ranges
//	        from 0 to 1. An alpha value of 0.5 results in centripetal spline,
//	        alpha=0 results in a uniform spline, and alpha=1 results
//	        in a chordal spline.
//	-plot   File path for the output of a plot image of the spline curve in PNG
//	        format. (optional, no plot image generated by default)
//
// The control points file is expected to be a text file with a tab or whitespace
// separated X and Y coordinate pair per line, e.g.
//
//	2	5
//	3	4.7
//	4	2
//
// If no control points file is specified the control points are read from the
// standard input.
package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"

	"github.com/fzipp/catmullrom"
)

func usage() {
	fail(`Calculates the points of a Catmull-Rom spline chain along a given series
of control points, writes the result to the standard output, and optionally
generates a plot image of the curve.

Usage:
    spline [-pps n] [-alpha a] [-plot png_image_file] [control_points_file]

Flags:
    -pps    Points per segment between two control points.
            (optional, default: 10)
    -alpha  Alpha value (optional, default: 0.5). The alpha value ranges
            from 0 to 1. An alpha value of 0.5 results in centripetal spline,
            alpha=0 results in a uniform spline, and alpha=1 results
            in a chordal spline.
    -plot   File path for the output of a plot image of the spline curve in PNG
            format. (optional, no plot image generated by default)

The control points file is expected to be a text file with a tab or whitespace
separated X and Y coordinate pair per line, e.g.

2	5
3	4.7
4	2

If no control points file is specified the control points are read from the
standard input.`)
}

func main() {
	pointsPerSegment := flag.Int("pps", 10, "")
	alpha := flag.Float64("alpha", 0.5, "")
	plotFilePath := flag.String("plot", "", "")

	flag.Usage = usage
	flag.Parse()

	var err error
	inputFile := os.Stdin
	if flag.NArg() > 0 {
		inputFile, err = os.Open(flag.Arg(0))
		check(err)
		defer inputFile.Close()
	}

	controlPoints, err := parsePoints(inputFile)
	check(err)

	curve := catmullrom.SplineChain(controlPoints, *pointsPerSegment, *alpha)

	for _, point := range curve {
		fmt.Printf("%v\t%v\n", point.X, point.Y)
	}

	if *plotFilePath != "" {
		err := savePlot(curve, controlPoints, *plotFilePath)
		check(err)
	}
}

func parsePoints(r io.Reader) ([]catmullrom.Point, error) {
	var points []catmullrom.Point
	scanner := bufio.NewScanner(r)
	for scanner.Scan() {
		fields := strings.Fields(scanner.Text())
		if len(fields) < 2 {
			continue
		}
		x, err := strconv.ParseFloat(fields[0], 64)
		if err != nil {
			return nil, fmt.Errorf("invalid X coordinate: '%s'", fields[0])
		}
		y, err := strconv.ParseFloat(fields[1], 64)
		if err != nil {
			return nil, fmt.Errorf("invalid Y coordinate: '%s'", fields[1])
		}
		points = append(points, catmullrom.Point{X: x, Y: y})
	}
	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("could not read from input: %w", err)
	}
	return points, nil
}

func check(err error) {
	if err != nil {
		fail(err)
	}
}

func fail(message any) {
	_, _ = fmt.Fprintln(os.Stderr, message)
	os.Exit(1)
}
